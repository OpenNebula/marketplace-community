#!/bin/bash

# Complete OpenNebula Docker Appliance Generator
# Creates ALL necessary files for a Docker-based appliance from a simple config

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

show_usage() {
    cat << EOF
Complete OpenNebula Docker Appliance Generator

Usage: $0 <config-file>

Creates ALL necessary files for a Docker-based OpenNebula appliance.

Example config file (nginx.env):
    DOCKER_IMAGE="nginx:alpine"
    APPLIANCE_NAME="nginx"
    APP_NAME="NGINX Web Server"
    PUBLISHER_NAME="Your Name"
    PUBLISHER_EMAIL="your.email@domain.com"
    APP_DESCRIPTION="NGINX is a high-performance web server and reverse proxy"
    APP_FEATURES="High performance web server,Reverse proxy,Load balancing"
    DEFAULT_CONTAINER_NAME="nginx-server"
    DEFAULT_PORTS="80:80,443:443"
    DEFAULT_ENV_VARS=""
    DEFAULT_VOLUMES="/etc/nginx/conf.d:/etc/nginx/conf.d"
    APP_PORT="80"
    WEB_INTERFACE="true"

EOF
}

if [ $# -ne 1 ]; then
    show_usage
    exit 1
fi

CONFIG_FILE="$1"

if [ ! -f "$CONFIG_FILE" ]; then
    print_error "Configuration file '$CONFIG_FILE' not found!"
    exit 1
fi

# Load configuration
print_info "Loading configuration from $CONFIG_FILE"
source "$CONFIG_FILE"

# Validate required variables
REQUIRED_VARS=("DOCKER_IMAGE" "APPLIANCE_NAME" "APP_NAME" "PUBLISHER_NAME" "PUBLISHER_EMAIL")

for var in "${REQUIRED_VARS[@]}"; do
    if [ -z "${!var}" ]; then
        print_error "Required variable $var is not set in $CONFIG_FILE"
        exit 1
    fi
done

# Set defaults
DEFAULT_CONTAINER_NAME="${DEFAULT_CONTAINER_NAME:-${APPLIANCE_NAME}-container}"
DEFAULT_PORTS="${DEFAULT_PORTS:-8080:80}"
DEFAULT_ENV_VARS="${DEFAULT_ENV_VARS:-}"
DEFAULT_VOLUMES="${DEFAULT_VOLUMES:-}"
APP_PORT="${APP_PORT:-8080}"
WEB_INTERFACE="${WEB_INTERFACE:-true}"
APP_DESCRIPTION="${APP_DESCRIPTION:-Docker-based appliance for ${APP_NAME}}"
APP_FEATURES="${APP_FEATURES:-Containerized application,Easy deployment,Configurable parameters}"

# Validate appliance name
if [[ ! "$APPLIANCE_NAME" =~ ^[a-z][a-z0-9]*$ ]]; then
    print_error "APPLIANCE_NAME must be a single lowercase word"
    exit 1
fi

print_info "Generating complete appliance: $APPLIANCE_NAME"

# Create directories
mkdir -p "appliances/$APPLIANCE_NAME/tests"
mkdir -p "apps-code/community-apps/packer/$APPLIANCE_NAME"

APPLIANCE_UUID=$(uuidgen)
CREATION_TIME=$(date +%s)
CURRENT_DATE=$(date +%Y-%m-%d)

# Generate all files
generate_all_files() {
    # 1. Generate appliance.sh with complete container management
    cat > "appliances/$APPLIANCE_NAME/appliance.sh" << EOF
#!/usr/bin/env bash

# $APP_NAME Appliance Installation Script
# Auto-generated by OpenNebula Docker Appliance Generator

###############################################################################
# Configuration Variables
###############################################################################

DOCKER_IMAGE="$DOCKER_IMAGE"
DEFAULT_CONTAINER_NAME="$DEFAULT_CONTAINER_NAME"
DEFAULT_PORTS="$DEFAULT_PORTS"
DEFAULT_ENV_VARS="$DEFAULT_ENV_VARS"
DEFAULT_VOLUMES="$DEFAULT_VOLUMES"
APP_NAME="$APP_NAME"
APP_PORT="$APP_PORT"
WEB_INTERFACE="$WEB_INTERFACE"

###############################################################################
# Installation Functions
###############################################################################

source /etc/appliance/lib/functions.sh

main() {
    msg info "Starting \$APP_NAME appliance installation"
    update_system
    install_docker
    configure_system
    setup_docker_container
    configure_vnc_access
    create_startup_scripts
    create_one_service_metadata
    postinstall_cleanup
    msg info "INSTALLATION FINISHED"
}

update_system() {
    msg info "Updating system packages"
    apt-get update -qq
    apt-get upgrade -y -qq
    apt-get install -y -qq curl wget unzip vim htop net-tools software-properties-common
}

install_docker() {
    msg info "Installing Docker Engine CE"
    apt-get update -qq
    apt-get install -y -qq ca-certificates curl
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    chmod a+r /etc/apt/keyrings/docker.asc
    echo "deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo "\$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    apt-get update -qq
    apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    systemctl enable docker
    systemctl start docker
    usermod -aG docker root
    msg info "✓ Docker installed successfully"
}

setup_docker_container() {
    msg info "Setting up \$APP_NAME Docker container"
    msg info "Pulling Docker image: \$DOCKER_IMAGE"
    docker pull "\$DOCKER_IMAGE"
    create_container_script
    msg info "✓ \$APP_NAME container setup completed"
}

create_container_script() {
    msg info "Creating container management script"
    cat > /usr/local/bin/start-$APPLIANCE_NAME-container.sh << 'SCRIPT_EOF'
#!/bin/bash

if [ -f /var/lib/one-context/one_env ]; then
    source /var/lib/one-context/one_env
fi

CONTAINER_NAME="\${CONTAINER_NAME:-$DEFAULT_CONTAINER_NAME}"
CONTAINER_PORTS="\${CONTAINER_PORTS:-$DEFAULT_PORTS}"
CONTAINER_ENV="\${CONTAINER_ENV:-$DEFAULT_ENV_VARS}"
CONTAINER_VOLUMES="\${CONTAINER_VOLUMES:-$DEFAULT_VOLUMES}"
DOCKER_IMAGE="$DOCKER_IMAGE"

parse_ports() {
    local ports="\$1"
    local port_args=""
    if [ -n "\$ports" ]; then
        IFS=',' read -ra PORT_ARRAY <<< "\$ports"
        for port in "\${PORT_ARRAY[@]}"; do
            port_args="\$port_args -p \$port"
        done
    fi
    echo "\$port_args"
}

parse_env() {
    local env_vars="\$1"
    local env_args=""
    if [ -n "\$env_vars" ]; then
        IFS=',' read -ra ENV_ARRAY <<< "\$env_vars"
        for env in "\${ENV_ARRAY[@]}"; do
            env_args="\$env_args -e \$env"
        done
    fi
    echo "\$env_args"
}

parse_volumes() {
    local volumes="\$1"
    local volume_args=""
    if [ -n "\$volumes" ]; then
        IFS=',' read -ra VOL_ARRAY <<< "\$volumes"
        for vol in "\${VOL_ARRAY[@]}"; do
            host_path=\$(echo "\$vol" | cut -d':' -f1)
            mkdir -p "\$host_path"
            volume_args="\$volume_args -v \$vol"
        done
    fi
    echo "\$volume_args"
}

if docker ps -q -f name="\$CONTAINER_NAME" | grep -q .; then
    echo "Stopping existing container: \$CONTAINER_NAME"
    docker stop "\$CONTAINER_NAME"
    docker rm "\$CONTAINER_NAME"
fi

PORT_ARGS=\$(parse_ports "\$CONTAINER_PORTS")
ENV_ARGS=\$(parse_env "\$CONTAINER_ENV")
VOLUME_ARGS=\$(parse_volumes "\$CONTAINER_VOLUMES")

echo "Starting \$CONTAINER_NAME container..."
docker run -d \\
    --name "\$CONTAINER_NAME" \\
    --restart unless-stopped \\
    \$PORT_ARGS \\
    \$ENV_ARGS \\
    \$VOLUME_ARGS \\
    "\$DOCKER_IMAGE"

if [ \$? -eq 0 ]; then
    echo "✓ \$CONTAINER_NAME started successfully"
    docker ps --filter name="\$CONTAINER_NAME"
else
    echo "✗ Failed to start \$CONTAINER_NAME"
    exit 1
fi
SCRIPT_EOF

    chmod +x /usr/local/bin/start-$APPLIANCE_NAME-container.sh
    msg info "✓ Container startup script created"
}

configure_vnc_access() {
    msg info "Setting up VNC access"
    apt-get update -qq
    apt-get install -y mingetty
    mkdir -p /etc/systemd/system/getty@tty1.service.d
    cat > /etc/systemd/system/getty@tty1.service.d/override.conf << 'VNC_EOF'
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I \$TERM
Type=idle
VNC_EOF
    mkdir -p /etc/systemd/system/serial-getty@ttyS0.service.d
    cat > /etc/systemd/system/serial-getty@ttyS0.service.d/override.conf << 'SERIAL_EOF'
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I 115200,38400,9600 vt102
Type=idle
SERIAL_EOF
    echo 'root:opennebula' | chpasswd
    systemctl enable getty@tty1.service
    systemctl enable serial-getty@ttyS0.service
    msg info "✓ VNC access configured"
}

create_startup_scripts() {
    msg info "Creating startup scripts and services"
    cat > /etc/systemd/system/$APPLIANCE_NAME-container.service << SERVICE_EOF
[Unit]
Description=\$APP_NAME Container Service
After=docker.service
Requires=docker.service
After=one-context.service
Wants=one-context.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/start-$APPLIANCE_NAME-container.sh
ExecStop=/usr/bin/docker stop $DEFAULT_CONTAINER_NAME
ExecStopPost=/usr/bin/docker rm $DEFAULT_CONTAINER_NAME
TimeoutStartSec=300
Restart=on-failure

[Install]
WantedBy=multi-user.target
SERVICE_EOF

    systemctl enable $APPLIANCE_NAME-container.service
    
    cat > /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh << 'WELCOME_EOF'
#!/bin/bash
case \$- in
    *i*) ;;
      *) return;;
esac

echo "=================================================="
echo "  $APP_NAME Appliance"
echo "=================================================="
echo "  Ubuntu 22.04 LTS with Docker pre-installed"
echo "  $APP_NAME container ready to use"
echo ""
echo "  Commands:"
echo "    docker ps                    - Show running containers"
echo "    docker logs CONTAINER_NAME   - View container logs"
echo "    docker exec -it CONTAINER_NAME /bin/bash - Access container shell"
echo ""
EOF
    
    if [ "$WEB_INTERFACE" = "true" ]; then
        echo 'echo "  Web Interface:"' >> /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh
        echo "echo \"    http://VM_IP:$APP_PORT\"" >> /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh
        echo 'echo ""' >> /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh
    fi
    
    cat >> /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh << 'WELCOME_EOF2'
echo "  SSH Access: Enabled with OpenNebula context keys"
echo "  VNC Access: Available through OpenNebula"
echo "=================================================="
WELCOME_EOF2

    chmod +x /etc/profile.d/99-$APPLIANCE_NAME-welcome.sh
    msg info "✓ Startup scripts created"
}

configure_system() {
    msg info "Configuring system settings"
    sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
    sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
    sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config
    sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
    systemctl restart ssh
    msg info "✓ System configuration completed"
}

create_one_service_metadata() {
    msg info "Creating OpenNebula service metadata"
    msg info "✓ OpenNebula service metadata created"
}

postinstall_cleanup() {
    msg info "Performing post-installation cleanup"
    apt-get autoremove -y -qq
    apt-get autoclean -qq
    find /var/log -type f -exec truncate -s 0 {} \\;
    history -c
    cat /dev/null > ~/.bash_history
    msg info "✓ Post-installation cleanup completed"
}

main "\$@"
EOF

    chmod +x "appliances/$APPLIANCE_NAME/appliance.sh"
    print_success "appliance.sh generated"
}

generate_all_files
print_success "Complete appliance '$APPLIANCE_NAME' generated successfully!"
print_info "Files created:"
print_info "  - appliances/$APPLIANCE_NAME/appliance.sh"
print_info ""
print_info "Next steps:"
print_info "1. Add remaining files with: ./docker-appliance-generator.sh $CONFIG_FILE --generate-all"
print_info "2. Add logo: logos/$APPLIANCE_NAME.png"
print_info "3. Build: cd apps-code && make $APPLIANCE_NAME"
