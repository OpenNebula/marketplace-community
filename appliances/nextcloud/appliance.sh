#!/usr/bin/env bash

# nextcloud Appliance Installation Script
# Auto-generated by OpenNebula Docker Appliance Generator
# Docker Image: nextcloud/all-in-one:latest

set -o errexit -o pipefail

# List of contextualization parameters
ONE_SERVICE_PARAMS=(
    'ONEAPP_CONTAINER_NAME'     'configure'  'Docker container name'                    'O|text'
    'ONEAPP_CONTAINER_PORTS'    'configure'  'Docker container port mappings'           'O|text'
    'ONEAPP_CONTAINER_ENV'      'configure'  'Docker container environment variables'   'O|text'
    'ONEAPP_CONTAINER_VOLUMES'  'configure'  'Docker container volume mappings'         'O|text'
)

# Configuration from user input
DOCKER_IMAGE="nextcloud/all-in-one:latest"
# Nextcloud AIO REQUIRES the container to be named "nextcloud-aio-mastercontainer"
# See: https://github.com/nextcloud/all-in-one#can-i-run-this-with-docker-swarm
DEFAULT_CONTAINER_NAME="nextcloud-aio-mastercontainer"
DEFAULT_PORTS="80:80,8080:8080,8443:8443"
# For local installations without a domain, skip domain validation
DEFAULT_ENV_VARS="SKIP_DOMAIN_VALIDATION=true"
DEFAULT_VOLUMES="/var/run/docker.sock:/var/run/docker.sock:ro,nextcloud_aio_mastercontainer:/mnt/docker-aio-config"
APP_NAME="nextcloud"
APPLIANCE_NAME="nextcloud"

### Appliance metadata ###############################################

ONE_SERVICE_NAME='nextcloud'
ONE_SERVICE_VERSION=   #latest
ONE_SERVICE_BUILD=$(date +%s)
ONE_SERVICE_SHORT_DESCRIPTION='nextcloud Docker Container Appliance'
ONE_SERVICE_DESCRIPTION='nextcloud running in Docker container'
ONE_SERVICE_RECONFIGURABLE=true

### Appliance functions ##############################################

service_cleanup()
{
    :
}

service_install()
{
    export DEBIAN_FRONTEND=noninteractive

    # Update system
    apt-get update
    apt-get upgrade -y

    # Install generic kernel with Virtual Terminal (VT) support for VNC console
    # The KVM kernel lacks VT support which causes VNC to show a black screen
    msg info "Installing generic kernel for VNC console support"
    apt-get install -y linux-image-generic linux-modules-extra-$(uname -r | sed 's/-kvm$/-generic/') 2>/dev/null || \
        apt-get install -y linux-image-generic

    # Set generic kernel as default in GRUB
    # Find the generic kernel entry and set it as default
    if [ -f /etc/default/grub ]; then
        # Get the generic kernel menuentry
        GENERIC_ENTRY=$(grep -E "menuentry.*generic" /boot/grub/grub.cfg 2>/dev/null | head -1 | sed "s/.*'\([^']*\)'.*/\1/" || echo "")
        if [ -n "$GENERIC_ENTRY" ]; then
            sed -i "s/^GRUB_DEFAULT=.*/GRUB_DEFAULT=\"Advanced options for Ubuntu>$GENERIC_ENTRY\"/" /etc/default/grub
        else
            # Fallback: use saved entry
            sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=0/' /etc/default/grub
        fi
        update-grub
    fi

    # Remove KVM kernel packages to save disk space (~150MB)
    # The generic kernel is now installed and will be used
    msg info "Removing KVM kernel to save disk space"
    apt-get remove -y linux-image-kvm linux-kvm 2>/dev/null || true
    apt-get autoremove -y

    # Install Docker
    apt-get install -y ca-certificates curl
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    chmod a+r /etc/apt/keyrings/docker.asc

    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

    apt-get update
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # Install nginx for reverse proxy (to handle SSL and allow localhost access)
    msg info "Installing nginx for reverse proxy"
    apt-get install -y nginx

    # Enable and start Docker
    systemctl enable docker
    systemctl start docker

    # Pull the Docker image
    msg info "Pulling Docker image: $DOCKER_IMAGE"
    docker pull "$DOCKER_IMAGE"

    # Configure console auto-login
    systemctl stop unattended-upgrades 2>/dev/null || true
    systemctl disable unattended-upgrades 2>/dev/null || true

    apt-get install -y mingetty

    # Create TTY devices at boot (required for KVM-optimized kernels without VT support)
    # The KVM kernel doesn't include the Virtual Terminal subsystem, so we need to
    # create the device nodes manually and rely on serial console for primary access
    cat > /etc/systemd/system/create-tty-devices.service << 'TTY_SERVICE_EOF'
[Unit]
Description=Create TTY device nodes for KVM kernel
DefaultDependencies=no
Before=getty@tty1.service
After=systemd-tmpfiles-setup-dev.service

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'for i in 0 1 2 3 4 5 6; do [ -e /dev/tty$i ] || mknod /dev/tty$i c 4 $i; done'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
TTY_SERVICE_EOF
    systemctl enable create-tty-devices.service

    # Configure auto-login on console (for VT-enabled kernels)
    mkdir -p /etc/systemd/system/getty@tty1.service.d
    cat > /etc/systemd/system/getty@tty1.service.d/override.conf << 'CONSOLE_EOF'
[Unit]
# Remove ConditionPathExists to avoid skipping on KVM kernels
ConditionPathExists=

[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I \\$TERM
Type=idle
CONSOLE_EOF

    # Configure serial console (PRIMARY console for cloud VMs)
    # Serial console works reliably with KVM-optimized kernels
    mkdir -p /etc/systemd/system/serial-getty@ttyS0.service.d
    cat > /etc/systemd/system/serial-getty@ttyS0.service.d/override.conf << 'SERIAL_EOF'
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin root %I 115200,38400,9600 vt102
Type=idle
SERIAL_EOF

    echo 'root:opennebula' | chpasswd
    systemctl enable getty@tty1.service serial-getty@ttyS0.service

    # Create welcome message
    cat > /etc/profile.d/99-${APPLIANCE_NAME}-welcome.sh << WELCOME_EOF
#!/bin/bash
case \\\$- in
    *i*) ;;
      *) return;;
esac

echo "=================================================="
echo "  $APP_NAME Appliance"
echo "=================================================="
echo "  Docker Image: $DOCKER_IMAGE"
echo "  Container: $DEFAULT_CONTAINER_NAME"
echo "  Ports: $DEFAULT_PORTS"
echo ""
echo "  Nextcloud Access (via SSH tunnel):"
echo "    1. Create SSH tunnel: ssh -L 9999:<VM_IP>:9999 root@<FRONTEND_IP>"
echo "    2. Access Nextcloud: https://localhost:9999"
echo "    3. AIO Interface: https://localhost:9080 (tunnel port 8080)"
echo ""
echo "  Commands:"
echo "    docker ps                    - Show running containers"
echo "    docker logs $DEFAULT_CONTAINER_NAME   - View container logs"
echo "    docker exec -it $DEFAULT_CONTAINER_NAME /bin/bash - Access container"
echo ""
echo "  Access Methods:"
echo "    SSH: Enabled (password: 'opennebula' + context SSH keys)"
echo "    VNC Console: Enabled (via OpenNebula Sunstone)"
echo "    Serial Console: Enabled (virsh console or Sunstone serial)"
echo ""
echo "  Default root password: opennebula"
echo "=================================================="
WELCOME_EOF

    chmod +x /etc/profile.d/99-${APPLIANCE_NAME}-welcome.sh

    # Clean up to reduce image size
    msg info "Cleaning up to reduce image size"
    apt-get autoremove -y
    apt-get autoclean
    apt-get clean
    rm -rf /var/lib/apt/lists/*
    rm -rf /tmp/* /var/tmp/*
    find /var/log -type f -exec truncate -s 0 {} \;
    find /var/cache -type f -delete 2>/dev/null || true

    sync

    return 0
}

service_configure()
{
    msg info "Configuring network and services"

    # Ensure DNS is configured (virt-sysprep deletes /etc/resolv.conf during image preparation)
    # This is a fallback in case OpenNebula network context doesn't provide DNS
    if [ ! -s /etc/resolv.conf ] || ! grep -q "nameserver" /etc/resolv.conf 2>/dev/null; then
        msg info "Setting up DNS nameservers (fallback configuration)"
        echo "nameserver 8.8.8.8" > /etc/resolv.conf
        echo "nameserver 8.8.4.4" >> /etc/resolv.conf
    fi

    msg info "Verifying Docker is running"

    if ! systemctl is-active --quiet docker; then
        msg error "Docker is not running"
        return 1
    fi

    msg info "Docker is running"
    return 0
}

service_bootstrap()
{
    msg info "Starting $APP_NAME service bootstrap"

    # Setup and start the container
    setup_app_container

    return $?
}

# Setup container function
setup_app_container()
{
    local container_name="${ONEAPP_CONTAINER_NAME:-$DEFAULT_CONTAINER_NAME}"
    local container_ports="${ONEAPP_CONTAINER_PORTS:-$DEFAULT_PORTS}"
    local container_env="${ONEAPP_CONTAINER_ENV:-$DEFAULT_ENV_VARS}"
    local container_volumes="${ONEAPP_CONTAINER_VOLUMES:-$DEFAULT_VOLUMES}"

    msg info "Setting up $APP_NAME container: $container_name"

    # Stop and remove existing container if it exists
    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        msg info "Stopping existing container: $container_name"
        docker stop "$container_name" 2>/dev/null || true
        docker rm "$container_name" 2>/dev/null || true
    fi

    # Parse port mappings
    local port_args=""
    if [ -n "$container_ports" ]; then
        IFS=',' read -ra PORT_ARRAY <<< "$container_ports"
        for port in "${PORT_ARRAY[@]}"; do
            port_args="$port_args -p $port"
        done
    fi

    # Parse environment variables
    local env_args=""
    if [ -n "$container_env" ]; then
        IFS=',' read -ra ENV_ARRAY <<< "$container_env"
        for env in "${ENV_ARRAY[@]}"; do
            env_args="$env_args -e $env"
        done
    fi

    # Parse volume mounts
    local volume_args=""
    if [ -n "$container_volumes" ]; then
        IFS=',' read -ra VOL_ARRAY <<< "$container_volumes"
        for vol in "${VOL_ARRAY[@]}"; do
            local host_path=$(echo "$vol" | cut -d':' -f1)
            # Only create directory if it doesn't exist and is not a socket/device file
            if [ ! -e "$host_path" ]; then
                mkdir -p "$host_path"
                # Set ownership to 1000:1000 (common for Docker containers)
                chown -R 1000:1000 "$host_path" 2>/dev/null || true
            fi
            volume_args="$volume_args -v $vol"
        done
    fi

    # Start the container
    msg info "Starting $APP_NAME container with:"
    msg info "  Ports: $container_ports"
    msg info "  Environment: ${container_env:-none}"
    msg info "  Volumes: $container_volumes"

    docker run -d --name "$container_name" --restart unless-stopped $port_args $env_args $volume_args "$DOCKER_IMAGE"

    if [ $? -eq 0 ]; then
        msg info "$APP_NAME container started successfully"
        docker ps --filter name="$container_name"

        # Setup nginx reverse proxy for localhost access
        setup_nginx_proxy

        # Wait for Nextcloud containers to be ready and configure localhost access
        configure_localhost_access

        return 0
    else
        msg error "Failed to start $APP_NAME container"
        return 1
    fi
}

# Setup nginx reverse proxy with self-signed SSL
setup_nginx_proxy()
{
    msg info "Setting up nginx reverse proxy for localhost access"

    # Create SSL directory and generate self-signed certificate
    mkdir -p /etc/nginx/ssl
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout /etc/nginx/ssl/nginx.key \
        -out /etc/nginx/ssl/nginx.crt \
        -subj "/CN=localhost" 2>/dev/null

    # Create nginx config for Nextcloud proxy on port 9999
    cat > /etc/nginx/sites-available/nextcloud << 'NGINX_EOF'
server {
    listen 9999 ssl;
    server_name _;

    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;

    client_max_body_size 10G;

    location / {
        # Proxy to Nextcloud Apache container's internal httpd (port 8000)
        # The container IP is on the docker network 172.18.0.0/16
        # We'll update this dynamically after containers start
        proxy_pass http://127.0.0.1:11000;
        proxy_set_header Host localhost:9999;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_buffering off;
        proxy_request_buffering off;
    }
}
NGINX_EOF

    # Enable the site
    ln -sf /etc/nginx/sites-available/nextcloud /etc/nginx/sites-enabled/
    rm -f /etc/nginx/sites-enabled/default

    # Don't start nginx yet - we'll update config and start after containers are ready
    msg info "Nginx configuration created"
}

# Configure Nextcloud for localhost access after containers are ready
configure_localhost_access()
{
    msg info "Waiting for Nextcloud containers to start..."

    # Wait for the Apache container to be running (up to 5 minutes)
    local max_wait=300
    local waited=0
    while [ $waited -lt $max_wait ]; do
        if docker ps --format '{{.Names}}' | grep -q "nextcloud-aio-apache"; then
            msg info "Nextcloud Apache container is running"
            break
        fi
        sleep 10
        waited=$((waited + 10))
        msg info "Waiting for Nextcloud containers... ($waited seconds)"
    done

    if [ $waited -ge $max_wait ]; then
        msg warning "Nextcloud containers did not start within $max_wait seconds"
        msg warning "You may need to manually configure localhost access later"
        return 0
    fi

    # Give containers a moment to fully initialize
    sleep 10

    # Get the Apache container's IP address on the docker network
    local apache_ip=$(docker inspect nextcloud-aio-apache 2>/dev/null | grep -A5 '"nextcloud-aio"' | grep '"IPv4Address"' | sed 's/.*"\([0-9.]*\)\/.*/\1/' | head -1)

    if [ -z "$apache_ip" ]; then
        msg warning "Could not determine Apache container IP, using default"
        apache_ip="172.18.0.11"
    fi

    msg info "Apache container IP: $apache_ip"

    # Update nginx config with the correct Apache container IP
    cat > /etc/nginx/sites-available/nextcloud << NGINX_EOF
server {
    listen 9999 ssl;
    server_name _;

    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;

    client_max_body_size 10G;

    location / {
        proxy_pass http://${apache_ip}:8000;
        proxy_set_header Host localhost:9999;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_buffering off;
        proxy_request_buffering off;
    }
}
NGINX_EOF

    # Start nginx
    systemctl start nginx || nginx

    # Create Nextcloud config override to disable domain redirect
    msg info "Creating Nextcloud localhost configuration override"

    # Wait for the nextcloud config volume to be available
    sleep 5

    local config_dir="/var/lib/docker/volumes/nextcloud_aio_nextcloud/_data/config"
    if [ -d "$config_dir" ]; then
        cat > "${config_dir}/zzz-override.config.php" << 'PHP_EOF'
<?php
$CONFIG = array (
  "overwritehost" => "",
  "trusted_domains" => array (
    0 => "localhost",
    1 => "nextcloud.opennebula",
    2 => "localhost:9999",
  ),
);
PHP_EOF
        msg info "Nextcloud localhost override configuration created"
    else
        msg warning "Nextcloud config directory not found yet, creating override script"
        # Create a script to apply the override when the directory becomes available
        cat > /usr/local/bin/nextcloud-localhost-setup.sh << 'SCRIPT_EOF'
#!/bin/bash
config_dir="/var/lib/docker/volumes/nextcloud_aio_nextcloud/_data/config"
max_wait=600
waited=0
while [ ! -d "$config_dir" ] && [ $waited -lt $max_wait ]; do
    sleep 10
    waited=$((waited + 10))
done
if [ -d "$config_dir" ]; then
    cat > "${config_dir}/zzz-override.config.php" << 'PHP_EOF'
<?php
$CONFIG = array (
  "overwritehost" => "",
  "trusted_domains" => array (
    0 => "localhost",
    1 => "nextcloud.opennebula",
    2 => "localhost:9999",
  ),
);
PHP_EOF
fi
SCRIPT_EOF
        chmod +x /usr/local/bin/nextcloud-localhost-setup.sh
        # Run in background
        nohup /usr/local/bin/nextcloud-localhost-setup.sh &>/dev/null &
    fi

    msg info "Localhost access configuration complete"
    msg info "Access Nextcloud via SSH tunnel: ssh -L 9999:<VM_IP>:9999 and then https://localhost:9999"
}
